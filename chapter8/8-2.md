## 8.2 함수 호출하기

### 8.2.1 함수호출하기

- whyNotFinish(전달인자,표현식); > 일반적 함수형태
- 전달인자 표현식이 평가가 되고 > 그 값이 함수의 매개변수로 대응이 된 다음 > 매개변수에서 실제 함수에 적용되는 순서.
- 반환되는 값은 return문에 따라서 있으면 그 다음 표현식 없으면 undefined
- 호출 컨택스트 (this) 의 결과값은 global 이다.

### 8.2.2 메서드 호출

- study.whyNotFinish() 메서드 형태
- . 또는 [] 대괄호 방식으로 사용가능
- 함수가 메소드를 아우르는 포괄적인 용어이다.
- 함수는 객체로부터 독립적이며, 메소드는 객체에 종속적이다.
- 메소드는 거의 모든 면에서 함수와 동일하지만, 아래의 2가지 포인트에서 다른 점이 있다.
- 메소드는 호출된 객체에 암시적으로 전달된다.
- 메소드는 클래스 안에 있는 data를 조작할 수 있다.(this를 통해서)
- 기본적으로 두 용어의 뜻은 동일하나 '객체(클래스)로부터 독립적인가 아닌가'가 함수와 메소드를 나누는 기준이다.

#### 메서드 호출 체이닝

```
ladder.up().up().down().showStep(); // 1
위와 같이 메서드 호출을 연속적으로 하기 위해서는 return this를 사용.

let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep: function() { // 사다리에서 몇 번째 단에 올라와 있는지 보여줌
    alert( this.step );
    return this;
  }
};
```

### 8.2.3 생성자 호출

함수나 메서드 앞에 new 있다고 한다면 생성자 호출이다 해당 생성자에 대해서는 9장에서 자세히 다룬다.

```
let o = new Object();
let o = new Object;
```

해당 생성자를 호출하면 생성자의 protptype을 상속반은 빈 객체가 생성된다.
해당 객체는 생성자 함수의 호출 컨텍스트로 사용되고 메서드 호출처럼 보일지라도 메서드가 아닌 객채가 호출 컨텍스트로 이용된다는 점이다.

return문 없이 보통으로 사용하며 최종적으로 새로 생성된 객체가 호출 표현식의 값이 된다.

만약 return 문을 사용해서 명시적으로 어떤 객체를 반환했다면 그건 생성자 호출 표현식의 값이 되고
단순히 return문 만 사용하거나 기존 자료형값을 반환한다면 반환값은 무시가 되고 그냥 새로 생성된 객체가 호출 표현식의 값이 된다

### 8.2.4 간접호출

함수는 객체이고 함수에도 메서드가 존재한다.
고로 call() , apply() 함수는 8.7장에서 자세히 설명한다.
