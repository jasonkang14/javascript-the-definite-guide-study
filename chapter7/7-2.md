## 7.2 배열의 원소 읽고 쓰기

배열의 각 원소에 접근할때는 [] 연산자를 사용한다.
여기서 []안에는 음이 아닌 정수의 값으로 평가되는 표현식이 위치할 수 있다.

```
//  콘솔에 찍어서 나오는 값 보기!!

let arr  = ["world"];
let firstValue = arr[0];
arr[1] = 2;
arr[arr[1]] = "Hi";  // 여기서 Hi는 arr 배열의 2번째 인덱스를 원소 값이다.
arr[arr[1]+1] = "Sophia";  // 여기서 Sophia는 arr 배열의 3번째 인덱스를 원소 값이다.
```

그리고 객체 프로퍼티에 접근하는 []와 똑같이 동작한다.

```
o= {};
o[1]="one";

o = {1: "one"}
```

위와 같이 객체[]의 인덱스가 1이라면 문자열 1로 변환해 "1"이라는 프로퍼티 네임에 one이라는 문자가 담기는 것이다.

여기서 배열의 인덱스와 객체 프로퍼티 이름을 구별하는 방법
모든 배열은 객체이고,
모든 인덱스 값은 프로퍼티 이름이지만,
프로퍼티 이름은 **0과 최대 인덱스가 가능한 값의 사이의 정수**여야만 **인덱스**가 될 수 있다.
또한 배열은 프로퍼티 가운데 인덱스인 것들은 사용하면 lenght 프로퍼티의 값이 자동으로 갱신된다.

배열[]안에 음수나 정수가 아닌 수들이 사용할 수 있기는 하다. 그렇게 되면 인덱스로 접근하는 것이 아니라 문자열로 변환해 위의 코드와 같이 **프로퍼티 네임**으로 사용된다.

```
a[-1.23]= true;
a[1.000] = 1;

a = {"-1.23": true, "1.000" : 1}
```

그러나 **양의 정수**가 담긴 **문자열**이 들어온다고 하면 그것은 **인덱스**로 인색해 해당 인덱스의 원소로 접근하게 된다.

```
a[1000] = 1;
// a 배열의 1000번째 원소에 값은 1이다.
```

자바스크립트 배열에서는 객체에 존재하지 않는 프로퍼티 이름의 질의 해도 에러가 발생하지 않고 단순히 undefined값이 반환된다. (배열에도 적용)

여기서 모든 배열은 객체임으로 객체에 프로토타입으로 부터 원소를 상속받을수 있고 getter , setter 메서드를 통해 정의된 원소도 가질 수 있으나, 배열에 사용하게 되면 일반 객체의 프로퍼티를 조회하는 시간이 비슷하기에 최적화에 대한 고려가 있다고 한다.
