## 9.6 자바스크립트의 객체지향 기법

### 9.6.1 set 클래스

set은 중복되지 않은 값을 정렬되지 않은 형태로 저장하는 데이터 구조를 말한다.

1. 어떤 값이 이미 집합에 있는지 검사
2. 값을 집합에 추가

아래 예제는 자바스크립트 값을 고유 문자열로 매핑하고 해당 문자열을 프로퍼티로 사용한다.
객체와 함수에는 단축된 형태로 자신을 확실하게 나태낼수있는 고유 문자열 표현이 없기때문에
아래 Set 클래스로 모든 객체와 함수에 프로퍼티 식별자를 정의하는 방식이다.

![](https://images.velog.io/images/dear_sopi9211/post/260edad3-64af-4439-896d-46a628c0f623/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.32.15.png)
![](https://images.velog.io/images/dear_sopi9211/post/66e52415-0ed4-49f2-a6d6-10cb3d1f26af/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.32.23.png)

### 9.6.2 열거형

나열될수 있는 유한 개의 값 집합을 사용해서 정의하는 자료형이다. 보통 키워드 enum 키워드를 사용한다.
ES5에서는 예약어 이지만 실제로는 사용되지는 않는다

![](https://images.velog.io/images/dear_sopi9211/post/a7e8eefb-1fb0-4765-9ac6-73fbca46a391/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.18.57.png)

### 9.6.3 표준 전환 메서드

toString()
객체의 문자열 표현을 반환하는 것이다.

toString()는 toLocaleString()과 관련이 있다. 객체를 로케일에 맞는 문자열로 변환한다.
객체는 > toString() > toLocaleString를 상속한다.

valueOf() 해당 메서드는 객체를 원시 값으로 변환한다.
객체가 숫자 컨택스트에서 산술연살자나 비교연산자와 함께 사용될때 자동으로 호출된다.
객체 대부분은 원시값으로 변환할 필요가 없으므로 대략 생략.

toJSON() 은 JSON.stringify()에 의해 자동으로 호출된다.

JSON은 데이터 구조를 직렬화 하는데 사용된다.

JSON.stringify() > JSON.parse() 전달하게 되면 객체의 메서드를 상속하지 않는다
그래서 toJSON() 메서드를 작성해서 객체를 직렬화 하지않고 호출 한다음 반환된 값을 직렬화 처리를 한다.

### 9.6.4 비교 메서드

자바스크립트의 동치 연산자들은 주어진 두 참조가 같은 객체를 가리키고 있는지 살펴본다.
두 객체에 프로퍼티를 비교하지는 않는다.
클래스를 정의하고 그 클래스의 인스턴스를 서로 비교하려면

equals() 라는 인스턴스 메서드를 정의해서 확인해야한다.

![](https://images.velog.io/images/dear_sopi9211/post/144c5974-8530-4a8c-93d1-9cd0e0ba3443/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.26.09.png)

조건에 따라서 인스턴스의 크기를 비교할수도 있는데 아래의 메서드 표현으로 조건처리가 가능하다.

![](https://images.velog.io/images/dear_sopi9211/post/cf91f726-5f27-4920-b55a-bb9dad036dc7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.27.14.png)

### 9.6.5 메서드 빌려오기

하나의 함수는 하나이상의 클래스의 메서드로 사용될수 있다.

메서드를 정의 할때 다른 클래스에 메서드를 빌려와서 정의할 수도 있다.![](https://images.velog.io/images/dear_sopi9211/post/534f09aa-a854-4076-aa34-a734957bd8a8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.30.31.png)

### 9.6.6 private 상태

객체지향 프로그래밍에서는 중요한 상태변수를 직접 읽거나 쓰는 것을 금지하고 객체의 메서드만 통해서 객체 상태에 접근하도록 허용함으로서 객체의 상태를 캡슐화 하거나 숨기는것을 목표로 삼는다.

책의 279페이지 기법을 통해서 캡슐화 하는 방식을 알아볼수 있다.

상태를 캡슐화 도록 하는 클로저를 사용하는 클래스는 그렇지 않은 클래스보다 확실히 느리고 크다.

### 9.6.7 생성자 오버로딩과 팩터리 메서드

객체를 한가지 이상의 방법으로 초기해야할 필요가 있다고 한다.
그럴때 생성자를 오버로드 하고 전달인자에 따라 각기 다른 초기화 작업이 수행되도록 처리한다고 한다.

여기서 팩터리 메서드의 좋은 점은 메서드 이름은 원하는 대로 지을수 있다는 좀이고 다른 이름의 메서드는 다른방식의 초기화를 할수 있다고 한다.
